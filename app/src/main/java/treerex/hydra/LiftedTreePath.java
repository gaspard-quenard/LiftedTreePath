/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package treerex.hydra;



import java.util.concurrent.Callable;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import fr.uga.pddl4j.parser.DefaultParsedProblem;
import fr.uga.pddl4j.parser.ErrorManager;
import fr.uga.pddl4j.parser.Message;
import fr.uga.pddl4j.parser.Parser;
import fr.uga.pddl4j.planners.LogLevel;
import fr.uga.pddl4j.problem.DefaultProblem;
import picocli.CommandLine;
import treerex.hydra.Encoder.LiftedTreePathEncoder;

@CommandLine.Command(name = "LiftedTreePath", version = "LiftedTreePath 0.1", description = "Solves a specified classical problem using SMT encoding.", sortOptions = false, mixinStandardHelpOptions = true, headerHeading = "Usage:%n", synopsisHeading = "%n", descriptionHeading = "%nDescription:%n%n", parameterListHeading = "%nParameters:%n", optionListHeading = "%nOptions:%n")
public class LiftedTreePath implements Callable<Integer> {

    private String problemPath = null;
    private String domainPath = null;

    /**
     * The class logger.
     */
    private static final Logger LOGGER = LogManager.getLogger(LiftedTreePath.class.getName());

    /**
     * Instantiates the planning problem from a parsed problem.
     *
     * @param problem the problem to instantiate.
     * @return the instantiated planning problem or null if the problem cannot be
     *         instantiated.
     */
    // @Override
    // public Problem instantiate(DefaultParsedProblem problem) {
    //     final Problem pb = new DefaultProblem(problem);
    //     pb.instantiate();
    //     return pb;
    // }


    /**
     * Command line option to set the problem path
     * 
     * @param domainPath the path of the problem file
     */
    @CommandLine.Option(names = { "-d",
            "--domain_path" }, paramLabel = "<domainPath>", description = "Path of the domain file", required = true)
    public void setDomainPath(final String domainPath) {
        this.domainPath = domainPath;
    }

    /**
     * Command line option to set the problem path
     * 
     * @param problemPath the path of the problem file
     */
    @CommandLine.Option(names = { "-p",
            "--problem_path" }, paramLabel = "<problemPath>", description = "Path of the problem file", required = true)
    public void setProblemPath(final String problemPath) {
        this.problemPath = problemPath;
    }

    @Override
    public Integer call() throws Exception {


        try {

            // 1. PARSE THE PROBLEM
            // Creates an instance of the PDDL parser
            final Parser parser = new Parser();
            // Disable log
            parser.setLogLevel(LogLevel.OFF);
            // Parses the domain and the problem files.
            final DefaultParsedProblem parsedProblem = parser.parse(this.domainPath, this.problemPath);
            // Gets the error manager of the parser
            final ErrorManager errorManager = parser.getErrorManager();
            // Checks if the error manager contains errors
            if (!errorManager.isEmpty()) {
                // Prints the errors
                for (Message m : errorManager.getMessages()) {
                    System.out.println(m.toString());
                }
            }
            // Create a problem
            final DefaultProblem problem = new DefaultProblem(parsedProblem);

            // Instantiate the planning problem
            problem.instantiate();

            // Run the encoder
            LiftedTreePathEncoder encoder = new LiftedTreePathEncoder(problem, this.domainPath, this.problemPath);

        } catch (Throwable t) {
            t.printStackTrace();
        }

        return 0;
    }





    // @Override
    // public Plan solve(Problem problem) {


    //     // Initialize the variables which will store the encoding time and solving time
    //     long deltaInitializingTreePathTime = 0;
    //     long deltaEncodingTime = 0;
    //     long deltaSolvingTime = 0;

    //     long beginInitializeTreePathTime = System.currentTimeMillis();

    //     // Initialize the encoder
    //     LiftedTreePathEncoder encoder = new LiftedTreePathEncoder(problem, this.getDomain(), this.getProblem());

    //     // Record the encoding time for the initial layer
    //     deltaInitializingTreePathTime = System.currentTimeMillis() - beginInitializeTreePathTime;

    //     LOGGER.info("Initializing tree path time: " + deltaInitializingTreePathTime + " ms.\n");

    //     // Initialize the layer index and maximum number of layers
    //     int layerIdx = 0;
    //     int maxLayers = 15;


    //     // If the SMT file is not satisfiable, return null
    //     return null;
    // }


    /**
     * The main method of the <code>SMT</code> planner.
     *
     * @param args the arguments of the command line.
     */
    public static void main(String[] args) {

        try {
            final LiftedTreePath planner = new LiftedTreePath();
            CommandLine cmd = new CommandLine(planner);
            cmd.execute(args);
        } catch (IllegalArgumentException e) {
            LOGGER.fatal(e.getMessage());
        }
    }


}